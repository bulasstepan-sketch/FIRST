<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Трекер тренировок Valorant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body class="min-h-screen bg-slate-950 text-slate-100">
    <main class="mx-auto flex w-full max-w-6xl flex-col gap-6 px-4 py-10 md:flex-row">
      <section class="w-full md:w-5/12">
        <div class="rounded-2xl border border-slate-800 bg-slate-900/80 p-5 shadow-xl">
          <div class="mb-4 flex items-center justify-between">
            <div class="flex flex-col gap-3">
              <div class="flex flex-wrap gap-3 text-xs uppercase tracking-widest text-slate-400">
                <label class="flex flex-col gap-1">
                  <span>Год</span>
                  <select
                    id="yearSelect"
                    class="rounded-lg border border-slate-800 bg-slate-950/60 px-2 py-1 text-sm text-slate-100 focus:border-red-500 focus:outline-none"
                  ></select>
                </label>
                <label class="flex flex-col gap-1">
                  <span>Месяц</span>
                  <select
                    id="monthSelect"
                    class="rounded-lg border border-slate-800 bg-slate-950/60 px-2 py-1 text-sm text-slate-100 focus:border-red-500 focus:outline-none"
                  ></select>
                </label>
              </div>
              <div>
                <p class="text-sm uppercase tracking-widest text-slate-400">Календарь</p>
                <h1 id="monthLabel" class="text-2xl font-semibold text-slate-100"></h1>
              </div>
            </div>
            <div class="rounded-full border border-red-500/30 bg-red-500/10 px-3 py-1 text-xs font-semibold uppercase tracking-wider text-red-300">
              Фокус Valorant
            </div>
          </div>
          <div class="grid grid-cols-7 gap-2 text-center text-xs uppercase tracking-widest text-slate-500">
            <span>ПН</span>
            <span>ВТ</span>
            <span>СР</span>
            <span>ЧТ</span>
            <span>ПТ</span>
            <span>СБ</span>
            <span>ВС</span>
          </div>
          <div id="calendarGrid" class="mt-3 grid grid-cols-7 gap-2"></div>
        </div>
      </section>

      <section class="flex w-full flex-col gap-6 md:w-7/12">
        <div class="rounded-2xl border border-slate-800 bg-slate-900/80 p-6 shadow-xl">
          <div class="mb-4 flex items-center justify-between">
            <div>
              <p class="text-sm uppercase tracking-widest text-slate-400">Тренировка за день</p>
              <h2 id="selectedDateLabel" class="text-xl font-semibold"></h2>
            </div>
            <span class="text-xs uppercase tracking-widest text-red-300">Трекер</span>
          </div>
          <div class="mb-4 flex flex-wrap items-center gap-3 text-xs uppercase tracking-widest text-slate-400">
            <span>Режим дня</span>
            <div class="flex overflow-hidden rounded-full border border-slate-800 bg-slate-950/60">
              <button
                id="modeTraining"
                type="button"
                class="px-4 py-2 text-xs font-semibold uppercase tracking-widest transition"
              >
                Тренировка
              </button>
              <button
                id="modeRest"
                type="button"
                class="px-4 py-2 text-xs font-semibold uppercase tracking-widest transition"
              >
                Отдых
              </button>
            </div>
          </div>
          <div>
            <div id="trainingPanel">
              <h3 class="mb-3 text-sm uppercase tracking-widest text-slate-400">План тренировки</h3>
              <ul id="planList" class="space-y-3"></ul>
            </div>
          </div>
          <div class="mt-6">
            <label for="dailyNote" class="text-sm uppercase tracking-widest text-slate-400">Заметка за день</label>
            <textarea
              id="dailyNote"
              rows="4"
              class="mt-2 w-full rounded-lg border border-slate-800 bg-slate-950/60 p-3 text-sm text-slate-100 focus:border-red-500 focus:outline-none"
              placeholder="Что получилось сегодня? Что нужно улучшить?"
            ></textarea>
          </div>
          <button
            id="saveDay"
            class="mt-4 w-full rounded-lg bg-red-500/90 px-4 py-2 text-sm font-semibold uppercase tracking-widest text-white hover:bg-red-400"
          >
            Сохранить
          </button>
        </div>

        <div class="rounded-2xl border border-slate-800 bg-slate-900/80 p-6 shadow-xl">
          <div class="mb-4 flex items-center justify-between">
            <div>
              <p class="text-sm uppercase tracking-widest text-slate-400">Редактор плана</p>
              <h3 class="text-lg font-semibold">Соберите свой план</h3>
            </div>
            <span class="text-xs uppercase tracking-widest text-red-300">Редактировать</span>
          </div>
          <form id="planForm" class="grid gap-4 md:grid-cols-3">
            <div class="md:col-span-1">
              <label class="text-xs uppercase tracking-widest text-slate-400">Название</label>
              <input
                id="blockTitle"
                class="mt-1 w-full rounded-lg border border-slate-800 bg-slate-950/60 px-3 py-2 text-sm focus:border-red-500 focus:outline-none"
                placeholder="Тренировка аима"
                required
              />
            </div>
            <div class="md:col-span-1">
              <label class="text-xs uppercase tracking-widest text-slate-400">Описание</label>
              <input
                id="blockDescription"
                class="mt-1 w-full rounded-lg border border-slate-800 bg-slate-950/60 px-3 py-2 text-sm focus:border-red-500 focus:outline-none"
                placeholder="Полигон + боты"
              />
            </div>
            <div class="md:col-span-1">
              <label class="text-xs uppercase tracking-widest text-slate-400">Длительность (мин)</label>
              <input
                id="blockDuration"
                type="number"
                min="0"
                class="mt-1 w-full rounded-lg border border-slate-800 bg-slate-950/60 px-3 py-2 text-sm focus:border-red-500 focus:outline-none"
                placeholder="20"
              />
            </div>
            <div class="md:col-span-3">
              <button
                class="w-full rounded-lg border border-red-500/50 bg-red-500/20 px-4 py-2 text-sm font-semibold uppercase tracking-widest text-red-200 hover:bg-red-500/30"
                type="submit"
              >
                Добавить упражнение
              </button>
            </div>
          </form>
          <p class="mt-4 text-xs text-slate-500">
            Совет: делайте упражнения короткими и сфокусированными для стабильности.
          </p>
        </div>
      </section>
    </main>

    <section class="mx-auto w-full max-w-6xl px-4 pb-10">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/80 p-6 shadow-xl">
        <div class="mb-4 flex items-center justify-between">
          <div>
            <p class="text-sm uppercase tracking-widest text-slate-400">Итоги</p>
            <h3 class="text-lg font-semibold">Статистика по упражнениям</h3>
          </div>
          <span class="text-xs uppercase tracking-widest text-red-300">Все дни</span>
        </div>
        <ul id="globalStatsList" class="space-y-2 text-sm text-slate-300"></ul>
      </div>
    </section>

    <script>
      // Data models
      /** @typedef {{ id: string, title: string, description?: string, durationMinutes?: number }} TrainingBlock */
      /** @typedef {TrainingBlock[]} TrainingPlan */
      /** @typedef {{ date: string, completedBlockIds: string[], note: string, mode: "training" | "rest", results: Record<string, number[]> }} DayEntry */

      const STORAGE_KEYS = {
        plan: "valorantTrainingPlan",
        entries: "valorantDayEntries",
      };

      const calendarGrid = document.getElementById("calendarGrid");
      const monthLabel = document.getElementById("monthLabel");
      const yearSelect = document.getElementById("yearSelect");
      const monthSelect = document.getElementById("monthSelect");
      const selectedDateLabel = document.getElementById("selectedDateLabel");
      const planList = document.getElementById("planList");
      const dailyNote = document.getElementById("dailyNote");
      const saveDay = document.getElementById("saveDay");
      const modeTraining = document.getElementById("modeTraining");
      const modeRest = document.getElementById("modeRest");
      const trainingPanel = document.getElementById("trainingPanel");
      const planForm = document.getElementById("planForm");
      const blockTitle = document.getElementById("blockTitle");
      const blockDescription = document.getElementById("blockDescription");
      const blockDuration = document.getElementById("blockDuration");
      const globalStatsList = document.getElementById("globalStatsList");

      let trainingPlan = loadTrainingPlan();
      let dayEntries = loadDayEntries();
      let selectedDate = getISODate(new Date());

      const MONTHS_RU = [
        "Январь",
        "Февраль",
        "Март",
        "Апрель",
        "Май",
        "Июнь",
        "Июль",
        "Август",
        "Сентябрь",
        "Октябрь",
        "Ноябрь",
        "Декабрь",
      ];

      const today = new Date();
      let currentYear = today.getFullYear();
      let currentMonth = today.getMonth();

      function getDayCompletionStatus(dateString) {
        if (trainingPlan.length === 0) {
          return "none";
        }

        const entry = dayEntries[dateString];
        if (!entry) {
          return "none";
        }

        const validBlockIds = new Set(trainingPlan.map((block) => block.id));
        const completedCount = entry.completedBlockIds.filter((id) => validBlockIds.has(id)).length;

        if (completedCount === 0) {
          return "none";
        }
        if (completedCount >= trainingPlan.length) {
          return "complete";
        }
        return "partial";
      }

      function applyCalendarStatus(button, status) {
        if (status === "complete") {
          button.classList.add("ring-1", "ring-inset", "ring-emerald-400/70");
        } else if (status === "partial") {
          button.classList.add("ring-1", "ring-inset", "ring-amber-300/70");
        }
      }

      // Calendar rendering logic for the selected month/year
      function renderCalendar() {
        calendarGrid.innerHTML = "";
        const firstDay = new Date(currentYear, currentMonth, 1);
        const lastDay = new Date(currentYear, currentMonth + 1, 0);
        // Используем русскую локаль для отображения месяца и года.
        monthLabel.textContent = firstDay.toLocaleDateString("ru-RU", {
          month: "long",
          year: "numeric",
        });

        // Неделя начинается с понедельника.
        const firstDayOffset = (firstDay.getDay() + 6) % 7;
        for (let i = 0; i < firstDayOffset; i += 1) {
          const spacer = document.createElement("div");
          calendarGrid.appendChild(spacer);
        }

        for (let day = 1; day <= lastDay.getDate(); day += 1) {
          const date = new Date(currentYear, currentMonth, day);
          const dateString = getISODate(date);
          const button = document.createElement("button");
          const hasEntry = Boolean(dayEntries[dateString]);
          const completionStatus = getDayCompletionStatus(dateString);

          button.type = "button";
          button.textContent = day;
          button.dataset.date = dateString;
          button.className =
            "rounded-lg border border-slate-800 px-2 py-3 text-sm transition hover:border-red-500/60 hover:text-red-200";

          if (dateString === selectedDate) {
            button.classList.add("bg-red-500/30", "text-red-100", "border-red-500");
          } else if (hasEntry) {
            button.classList.add("bg-slate-800/70", "text-slate-200");
          } else {
            button.classList.add("bg-slate-950/40", "text-slate-400");
          }

          applyCalendarStatus(button, completionStatus);

          button.addEventListener("click", () => {
            selectedDate = dateString;
            renderCalendar();
            renderDayPanel();
          });

          calendarGrid.appendChild(button);
        }
      }

      // Render blocks and daily note for selected date
      function renderDayPanel() {
        selectedDateLabel.textContent = formatDisplayDate(selectedDate);
        const entry = getDayEntry(selectedDate);
        dailyNote.value = entry.note;
        updateModeToggle(entry.mode);

        planList.innerHTML = "";
        updateTrainingPanelState(entry.mode);
        if (trainingPlan.length === 0) {
          const emptyState = document.createElement("p");
          emptyState.className = "text-sm text-slate-500";
          emptyState.textContent = "Пока нет упражнений. Добавьте первое упражнение ниже.";
          planList.appendChild(emptyState);
          return;
        }

        trainingPlan.forEach((block) => {
          const listItem = document.createElement("li");
          listItem.className = "flex items-start justify-between gap-4 rounded-xl border border-slate-800 bg-slate-950/60 p-3";

          const info = document.createElement("div");
          const title = document.createElement("p");
          title.className = "text-sm font-semibold text-slate-100";
          title.textContent = block.title;
          info.appendChild(title);

          if (block.description) {
            const description = document.createElement("p");
            description.className = "text-xs text-slate-400";
            description.textContent = block.description;
            info.appendChild(description);
          }

          if (block.durationMinutes) {
            const duration = document.createElement("p");
            duration.className = "text-xs text-slate-500";
            duration.textContent = `${block.durationMinutes} мин`;
            info.appendChild(duration);
          }

          const resultsWrapper = document.createElement("div");
          resultsWrapper.className = "mt-3 flex flex-col gap-2";

          const resultsLabel = document.createElement("label");
          resultsLabel.className = "text-xs uppercase tracking-widest text-slate-400";
          resultsLabel.textContent = "Результаты (через запятую)";

          const resultsInput = document.createElement("input");
          resultsInput.type = "text";
          resultsInput.placeholder = "17, 21, 19, +";
          resultsInput.className =
            "w-full rounded-lg border border-slate-800 bg-slate-950/60 px-3 py-2 text-xs text-slate-100 focus:border-red-500 focus:outline-none";
          const existingResults = entry.results[block.id] || [];
          resultsInput.value = existingResults.join(", ");
          resultsInput.disabled = entry.mode === "rest";

          const statsText = document.createElement("p");
          statsText.className = "text-xs text-slate-500";
          statsText.textContent = buildStatsLabel(existingResults);

          const comparisonText = document.createElement("p");
          comparisonText.className = "text-xs text-slate-500";
          comparisonText.textContent = buildComparisonLabel(block.id, selectedDate, existingResults);

          const chartToggle = document.createElement("button");
          chartToggle.type = "button";
          chartToggle.className =
            "mt-2 text-xs uppercase tracking-widest text-red-300 hover:text-red-200";
          chartToggle.textContent = "Показать график";

          const chartPanel = document.createElement("div");
          chartPanel.className = "mt-2 hidden rounded-lg border border-slate-800 bg-slate-950/60 p-3";

          const chartTitle = document.createElement("p");
          chartTitle.className = "text-xs uppercase tracking-widest text-slate-400";
          chartTitle.textContent = "Последние 10 тренировок";

          // Высота графика контролируется контейнером, чтобы не растягивать блоки.
          const chartContainer = document.createElement("div");
          chartContainer.className = "mt-2 w-full max-w-full h-60 max-h-[40vh]";

          const chartCanvas = document.createElement("canvas");
          chartCanvas.className = "h-full w-full";

          const chartEmptyText = document.createElement("p");
          chartEmptyText.className = "mt-2 text-xs text-slate-500";
          chartEmptyText.textContent = "Недостаточно данных для построения графика";

          chartPanel.appendChild(chartTitle);
          chartContainer.appendChild(chartCanvas);
          chartPanel.appendChild(chartContainer);
          chartPanel.appendChild(chartEmptyText);

          let chartInstance = null;

          // Инициализируем и обновляем график, пересчитывая набор данных для блока.
          function refreshBlockChart() {
            const series = buildBlockChartSeries(block.id);
            if (series.labels.length === 0) {
              chartTitle.classList.add("hidden");
              chartCanvas.classList.add("hidden");
              chartEmptyText.classList.remove("hidden");
              if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
              }
              return;
            }

            chartTitle.classList.remove("hidden");
            chartCanvas.classList.remove("hidden");
            chartEmptyText.classList.add("hidden");

            if (chartInstance) {
              chartInstance.data.labels = series.labels;
              chartInstance.data.datasets[0].data = series.data;
              chartInstance.update();
              return;
            }

            const ctx = chartCanvas.getContext("2d");
            chartInstance = new Chart(ctx, {
              type: "line",
              data: {
                labels: series.labels,
                datasets: [
                  {
                    data: series.data,
                    borderColor: "rgba(244, 63, 94, 0.9)",
                    backgroundColor: "rgba(244, 63, 94, 0.2)",
                    pointRadius: 3,
                    tension: 0.35,
                    fill: true,
                  },
                ],
              },
              options: {
                responsive: true,
                // Размер задаётся контейнером, поэтому отключаем сохранение пропорций.
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                },
                scales: {
                  x: {
                    ticks: { color: "#94a3b8", maxRotation: 0 },
                    grid: { color: "rgba(148, 163, 184, 0.1)" },
                  },
                  y: {
                    ticks: { color: "#94a3b8" },
                    grid: { color: "rgba(148, 163, 184, 0.1)" },
                  },
                },
              },
            });
          }

          resultsInput.addEventListener("input", () => {
            if (entry.mode === "rest") {
              return;
            }
            const parsedResults = parseResultsInput(resultsInput.value);
            entry.results[block.id] = parsedResults;
            dayEntries[selectedDate] = entry;
            statsText.textContent = buildStatsLabel(parsedResults);
            comparisonText.textContent = buildComparisonLabel(block.id, selectedDate, parsedResults);
            renderGlobalStats();
            if (!chartPanel.classList.contains("hidden")) {
              refreshBlockChart();
            }
          });

          resultsWrapper.appendChild(resultsLabel);
          resultsWrapper.appendChild(resultsInput);
          resultsWrapper.appendChild(statsText);
          resultsWrapper.appendChild(comparisonText);
          resultsWrapper.appendChild(chartToggle);
          resultsWrapper.appendChild(chartPanel);
          info.appendChild(resultsWrapper);

          chartToggle.addEventListener("click", () => {
            const isHidden = chartPanel.classList.contains("hidden");
            if (isHidden) {
              chartPanel.classList.remove("hidden");
              chartToggle.textContent = "Скрыть график";
              refreshBlockChart();
              return;
            }
            chartPanel.classList.add("hidden");
            chartToggle.textContent = "Показать график";
          });

          const controls = document.createElement("div");
          controls.className = "flex flex-col items-end gap-2";

          const label = document.createElement("label");
          label.className = "flex items-center gap-2 text-xs uppercase tracking-widest text-slate-400";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = entry.completedBlockIds.includes(block.id);
          checkbox.disabled = entry.mode === "rest";
          checkbox.className = "h-4 w-4 rounded border-slate-700 bg-slate-950 text-red-500 focus:ring-red-500";
          checkbox.addEventListener("change", () => {
            toggleBlockCompletion(block.id, checkbox.checked);
          });

          const checkboxText = document.createElement("span");
          checkboxText.textContent = "Выполнено";

          label.appendChild(checkbox);
          label.appendChild(checkboxText);

          const deleteButton = document.createElement("button");
          deleteButton.type = "button";
          deleteButton.className = "text-xs uppercase tracking-widest text-red-300 hover:text-red-200";
          deleteButton.textContent = "Удалить";
          deleteButton.addEventListener("click", () => {
            deleteBlock(block.id);
          });

          controls.appendChild(label);
          controls.appendChild(deleteButton);

          listItem.appendChild(info);
          listItem.appendChild(controls);
          planList.appendChild(listItem);
        });
        renderGlobalStats();
      }

      // Save logic for daily entry
      saveDay.addEventListener("click", () => {
        const entry = getDayEntry(selectedDate);
        entry.note = dailyNote.value.trim();
        entry.mode = getSelectedMode();
        entry.results = entry.results || {};
        dayEntries[selectedDate] = entry;
        persistDayEntries();
        renderCalendar();
        renderGlobalStats();
      });

      // Add new training block
      planForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const title = blockTitle.value.trim();
        if (!title) {
          return;
        }

        const block = {
          id: crypto.randomUUID(),
          title,
          description: blockDescription.value.trim() || undefined,
          durationMinutes: blockDuration.value ? Number(blockDuration.value) : undefined,
        };

        trainingPlan.push(block);
        persistTrainingPlan();
        planForm.reset();
        renderDayPanel();
        renderCalendar();
        renderGlobalStats();
      });

      function deleteBlock(blockId) {
        trainingPlan = trainingPlan.filter((block) => block.id !== blockId);
        Object.values(dayEntries).forEach((entry) => {
          entry.completedBlockIds = entry.completedBlockIds.filter((id) => id !== blockId);
          if (entry.results) {
            delete entry.results[blockId];
          }
        });
        persistTrainingPlan();
        persistDayEntries();
        renderDayPanel();
        renderCalendar();
        renderGlobalStats();
      }

      function toggleBlockCompletion(blockId, isCompleted) {
        const entry = getDayEntry(selectedDate);
        if (entry.mode === "rest") {
          return;
        }
        if (isCompleted) {
          if (!entry.completedBlockIds.includes(blockId)) {
            entry.completedBlockIds.push(blockId);
          }
        } else {
          entry.completedBlockIds = entry.completedBlockIds.filter((id) => id !== blockId);
        }
        dayEntries[selectedDate] = entry;
        persistDayEntries();
        renderCalendar();
        renderGlobalStats();
      }

      // Local storage helpers
      function loadTrainingPlan() {
        const stored = localStorage.getItem(STORAGE_KEYS.plan);
        if (!stored) {
          return [];
        }
        try {
          return JSON.parse(stored);
        } catch (error) {
          return [];
        }
      }

      // Загружаем все записи дней из localStorage в виде массива.
      function loadAllDayEntries() {
        const stored = localStorage.getItem(STORAGE_KEYS.entries);
        if (!stored) {
          return [];
        }
        try {
          const entries = JSON.parse(stored);
          return Array.isArray(entries) ? entries : Object.values(entries);
        } catch (error) {
          return [];
        }
      }

      function loadDayEntries() {
        const entries = loadAllDayEntries();
        return entries.reduce((acc, entry) => {
          acc[entry.date] = entry;
          return acc;
        }, {});
      }

      function persistTrainingPlan() {
        localStorage.setItem(STORAGE_KEYS.plan, JSON.stringify(trainingPlan));
      }

      function persistDayEntries() {
        const entriesArray = Object.values(dayEntries);
        localStorage.setItem(STORAGE_KEYS.entries, JSON.stringify(entriesArray));
      }

      function getDayEntry(date) {
        const entry = dayEntries[date];
        if (!entry) {
          return {
            date,
            completedBlockIds: [],
            note: "",
            mode: "training",
            results: {},
          };
        }
        return {
          date,
          completedBlockIds: entry.completedBlockIds || [],
          note: entry.note || "",
          mode: entry.mode || "training",
          results: entry.results || {},
        };
      }

      // Поддержка нового режима дня (тренировка/отдых) с визуальным состоянием.
      function updateModeToggle(mode) {
        const isTraining = mode !== "rest";
        modeTraining.className = `px-4 py-2 text-xs font-semibold uppercase tracking-widest transition ${
          isTraining ? "bg-red-500/80 text-white" : "text-slate-400 hover:text-slate-200"
        }`;
        modeRest.className = `px-4 py-2 text-xs font-semibold uppercase tracking-widest transition ${
          isTraining ? "text-slate-400 hover:text-slate-200" : "bg-slate-700/80 text-white"
        }`;
      }

      function updateTrainingPanelState(mode) {
        const isRest = mode === "rest";
        trainingPanel.className = isRest ? "opacity-50 pointer-events-none" : "";
      }

      function getSelectedMode() {
        return modeRest.classList.contains("bg-slate-700/80") ? "rest" : "training";
      }

      modeTraining.addEventListener("click", () => {
        const entry = getDayEntry(selectedDate);
        entry.mode = "training";
        dayEntries[selectedDate] = entry;
        updateModeToggle(entry.mode);
        updateTrainingPanelState(entry.mode);
        renderDayPanel();
      });

      modeRest.addEventListener("click", () => {
        const entry = getDayEntry(selectedDate);
        entry.mode = "rest";
        dayEntries[selectedDate] = entry;
        updateModeToggle(entry.mode);
        updateTrainingPanelState(entry.mode);
        renderDayPanel();
      });

      // Парсер результатов: берём только числовые значения из строки.
      function parseResultsInput(value) {
        return value
          .split(",")
          .map((token) => token.trim())
          .map((token) => Number(token))
          .filter((token) => Number.isFinite(token));
      }

      // Подсчёт статистики по результатам за день.
      function buildStatsLabel(results) {
        if (!results.length) {
          return "Нет данных";
        }
        const min = Math.min(...results);
        const max = Math.max(...results);
        const avg = results.reduce((sum, value) => sum + value, 0) / results.length;
        return `Мин: ${formatStatNumber(min)}, Макс: ${formatStatNumber(max)}, Среднее: ${formatStatNumber(avg)}`;
      }

      // Сравниваем средний результат с последними 10 тренировочными днями.
      function buildComparisonLabel(blockId, dateString, results) {
        if (!results.length) {
          return "Сравнение с последними 10 тренировками: нет данных для сравнения";
        }

        const avgToday = results.reduce((sum, value) => sum + value, 0) / results.length;
        const avgLast10 = computeAverageForLastTenTrainingDays(blockId, dateString);

        if (!avgLast10) {
          return "Сравнение с последними 10 тренировками: нет данных для сравнения";
        }

        const deltaPercent = ((avgToday - avgLast10) / avgLast10) * 100;
        return `Сравнение с последними 10 тренировками: ${formatPercentDelta(deltaPercent)}`;
      }

      function buildBlockChartSeries(blockId) {
        const entriesWithAverages = getAllDayEntries()
          .map((entry) => {
            const results = entry.results?.[blockId];
            if (!Array.isArray(results)) {
              return null;
            }
            const numericResults = results.filter((value) => Number.isFinite(value));
            if (numericResults.length === 0) {
              return null;
            }
            const avg = numericResults.reduce((sum, value) => sum + value, 0) / numericResults.length;
            return { date: entry.date, avg };
          })
          .filter(Boolean)
          .sort((a, b) => a.date.localeCompare(b.date));

        // Собираем дни с данными по блоку, сортируем по дате и берём последние 10.
        const lastTenEntries = entriesWithAverages.slice(-10);

        return {
          labels: lastTenEntries.map((entry) => formatChartDateLabel(entry.date)),
          data: lastTenEntries.map((entry) => entry.avg),
        };
      }

      function formatChartDateLabel(dateString) {
        const date = new Date(`${dateString}T00:00:00`);
        return date.toLocaleDateString("ru-RU", { day: "2-digit", month: "2-digit" });
      }

      function formatPercentDelta(value) {
        const rounded = Math.round(value * 10) / 10;
        const formatted = Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(1);
        return `${rounded >= 0 ? "+" : ""}${formatted}%`;
      }

      function formatStatNumber(value) {
        return Number.isInteger(value) ? String(value) : value.toFixed(1);
      }

      function getAllDayEntries() {
        return Object.values(dayEntries);
      }

      // Собираем средние значения по каждому упражнению за всё время.
      function computeGlobalBlockAverages() {
        const totals = {};
        const counts = {};

        getAllDayEntries().forEach((entry) => {
          if (!entry.results) {
            return;
          }
          Object.entries(entry.results).forEach(([blockId, results]) => {
            if (!Array.isArray(results) || results.length === 0) {
              return;
            }
            results.forEach((value) => {
              if (!Number.isFinite(value)) {
                return;
              }
              totals[blockId] = (totals[blockId] || 0) + value;
              counts[blockId] = (counts[blockId] || 0) + 1;
            });
          });
        });

        return Object.keys(totals).reduce((acc, blockId) => {
          acc[blockId] = totals[blockId] / counts[blockId];
          return acc;
        }, {});
      }

      // Средний результат по последним 10 тренировочным дням для блока.
      function computeAverageForLastTenTrainingDays(blockId, dateString) {
        const previousEntries = getAllDayEntries()
          .filter((entry) => entry.mode === "training" && entry.date < dateString)
          .sort((a, b) => b.date.localeCompare(a.date))
          .slice(0, 10);

        const values = [];
        previousEntries.forEach((entry) => {
          const results = entry.results?.[blockId];
          if (!Array.isArray(results)) {
            return;
          }
          results.forEach((value) => {
            if (Number.isFinite(value)) {
              values.push(value);
            }
          });
        });

        if (!values.length) {
          return null;
        }

        const avg = values.reduce((sum, value) => sum + value, 0) / values.length;
        return avg === 0 ? null : avg;
      }

      function renderGlobalStats() {
        globalStatsList.innerHTML = "";
        if (trainingPlan.length === 0) {
          const emptyState = document.createElement("li");
          emptyState.className = "text-sm text-slate-500";
          emptyState.textContent = "Нет упражнений для статистики.";
          globalStatsList.appendChild(emptyState);
          return;
        }

        const averages = computeGlobalBlockAverages();

        trainingPlan.forEach((block) => {
          const item = document.createElement("li");
          item.className = "flex flex-wrap items-center justify-between gap-2 rounded-lg border border-slate-800/60 bg-slate-950/50 px-3 py-2";

          const title = document.createElement("span");
          title.className = "text-sm font-semibold text-slate-200";
          title.textContent = block.title;

          const value = document.createElement("span");
          const average = averages[block.id];
          value.className = "text-xs uppercase tracking-widest text-slate-400";
          value.textContent = Number.isFinite(average)
            ? `Среднее за всё время: ${formatStatNumber(average)}`
            : "Нет данных";

          item.appendChild(title);
          item.appendChild(value);
          globalStatsList.appendChild(item);
        });
      }

      function getISODate(date) {
        return date.toISOString().split("T")[0];
      }

      function formatDisplayDate(dateString) {
        const date = new Date(`${dateString}T00:00:00`);
        // Русское форматирование даты для заголовка.
        return date.toLocaleDateString("ru-RU", {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric",
        });
      }

      function populateSelectors() {
        // Заполняем список годов и месяцев для управления календарем.
        for (let year = 2020; year <= 2035; year += 1) {
          const option = document.createElement("option");
          option.value = String(year);
          option.textContent = year;
          yearSelect.appendChild(option);
        }

        MONTHS_RU.forEach((monthName, index) => {
          const option = document.createElement("option");
          option.value = String(index);
          option.textContent = monthName;
          monthSelect.appendChild(option);
        });

        yearSelect.value = String(currentYear);
        monthSelect.value = String(currentMonth);
      }

      function syncSelectedDate(year, month) {
        // Если выбранный день существует в новом месяце, сохраняем номер дня.
        const selectedDay = new Date(`${selectedDate}T00:00:00`).getDate();
        const lastDay = new Date(year, month + 1, 0).getDate();
        const nextDay = selectedDay <= lastDay ? selectedDay : 1;
        selectedDate = getISODate(new Date(year, month, nextDay));
      }

      function handleSelectorChange() {
        currentYear = Number(yearSelect.value);
        currentMonth = Number(monthSelect.value);
        syncSelectedDate(currentYear, currentMonth);
        renderCalendar();
        renderDayPanel();
      }

      yearSelect.addEventListener("change", handleSelectorChange);
      monthSelect.addEventListener("change", handleSelectorChange);

      populateSelectors();
      renderCalendar();
      renderDayPanel();
      renderGlobalStats();
    </script>
  </body>
</html>
